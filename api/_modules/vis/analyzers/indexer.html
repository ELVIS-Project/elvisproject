<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>vis.analyzers.indexer &mdash; vis X documentation</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     'X',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="../../../about.html" />
    <link rel="top" title="vis X documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">vis X documentation</a> &raquo;</li>
          <li><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for vis.analyzers.indexer</h1><div class="highlight"><pre>
<span class="c">#!/usr/bin/env python</span>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="c">#--------------------------------------------------------------------------------------------------</span>
<span class="c"># Program Name:           vis</span>
<span class="c"># Program Description:    Helps analyze music with computers.</span>
<span class="c">#</span>
<span class="c"># Filename:               controllers/indexer.py</span>
<span class="c"># Purpose:                Help with indexing data from musical scores.</span>
<span class="c">#</span>
<span class="c"># Copyright (C) 2013 Christopher Antila, Jamie Klassen</span>
<span class="c">#</span>
<span class="c"># This program is free software: you can redistribute it and/or modify</span>
<span class="c"># it under the terms of the GNU Affero General Public License as</span>
<span class="c"># published by the Free Software Foundation, either version 3 of the</span>
<span class="c"># License, or (at your option) any later version.</span>
<span class="c">#</span>
<span class="c"># This program is distributed in the hope that it will be useful,</span>
<span class="c"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c"># GNU Affero General Public License for more details.</span>
<span class="c">#</span>
<span class="c"># You should have received a copy of the GNU Affero General Public License</span>
<span class="c"># along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c">#--------------------------------------------------------------------------------------------------</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The controllers that deal with indexing data from music21 Score objects.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">pandas</span>
<span class="kn">from</span> <span class="nn">music21</span> <span class="kn">import</span> <span class="n">stream</span><span class="p">,</span> <span class="n">converter</span>


<div class="viewcode-block" id="mpi_unique_offsets"><a class="viewcode-back" href="../../../vis.analyzers.html#vis.analyzers.indexer.mpi_unique_offsets">[docs]</a><span class="k">def</span> <span class="nf">mpi_unique_offsets</span><span class="p">(</span><span class="n">streams</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For a set of streams, find the offsets at which events begin. Used by mp_indexer.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>
<span class="sd">    :param streams: A list of Streams in which to find the offsets at which events begin.</span>
<span class="sd">    :type streams: list of music21.stream.Stream</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>
<span class="sd">    :returns: A list of floating-point numbers representing offsets at which a new event begins in</span>
<span class="sd">        any of the streams. Offsets are sorted from lowest to highest (start to end).</span>
<span class="sd">    :rtype: list of float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">offsets</span> <span class="o">=</span> <span class="p">({</span><span class="n">e</span><span class="o">.</span><span class="n">offset</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">part</span><span class="o">.</span><span class="n">elements</span><span class="p">}</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">streams</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="n">offsets</span><span class="p">))</span>  <span class="c"># pylint: disable=W0142</span>

</div>
<div class="viewcode-block" id="mpi_vert_aligner"><a class="viewcode-back" href="../../../vis.analyzers.html#vis.analyzers.indexer.mpi_vert_aligner">[docs]</a><span class="k">def</span> <span class="nf">mpi_vert_aligner</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    When there is more than one event at an offset, call this method to ensure parsing</span>
<span class="sd">    simultaneities.</span>

<span class="sd">    Example:</span>
<span class="sd">    Transforms this...</span>
<span class="sd">    [[1, 2, 3], [1, 2, 3], [1, 2]]</span>
<span class="sd">    ... into this...</span>
<span class="sd">    [[1, 1, 1], [2, 2, 2], [3, 3]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">post</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">events</span><span class="p">])):</span>
        <span class="c"># for every &#39;i&#39; from 0 to the highest index of any object at this offset</span>
        <span class="n">this_e</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">events</span><span class="p">)):</span>
            <span class="c"># for every part</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">this_e</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">events</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="c"># when some parts have fewer objects at this offset</span>
                <span class="k">pass</span>
        <span class="n">post</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_e</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">post</span>

</div>
<div class="viewcode-block" id="stream_indexer"><a class="viewcode-back" href="../../../vis.analyzers.html#vis.analyzers.indexer.stream_indexer">[docs]</a><span class="k">def</span> <span class="nf">stream_indexer</span><span class="p">(</span><span class="n">pipe_index</span><span class="p">,</span> <span class="n">parts</span><span class="p">,</span> <span class="n">indexer_func</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform the indexation of a part or part combination. This is a module-level function designed</span>
<span class="sd">    to ease implementation of multiprocessing.</span>

<span class="sd">    If your Indexer has settings, use the indexer_func() to adjust for them.</span>

<span class="sd">    If an offset has multiple events of the correct type, only the &quot;first&quot; discovered results will</span>
<span class="sd">    be included in the output. This may produce misleading results when, for example, a double-stop</span>
<span class="sd">    was imported as two Note objects in the same Part, rather than as a Chord.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>
<span class="sd">    :param pipe_index: An identifier value for use by the caller.</span>
<span class="sd">    :type pipe_index: any</span>

<span class="sd">    :param parts: A list of at least one Stream object. Every new event, or change of simlutaneity,</span>
<span class="sd">        will appear in the outputted index. Therefore, the new index will contain at least as many</span>
<span class="sd">        events as the inputted Part or Series with the most events.</span>
<span class="sd">    :type parts: list of music21.stream.Stream</span>

<span class="sd">    :param indexer_func: This function transforms found events into a unicode object.</span>
<span class="sd">    :type indexer_func: function</span>

<span class="sd">    :param types: Only objects of a type in this list will be passed to the indexer_func for</span>
<span class="sd">        inclusion in the resulting index.</span>
<span class="sd">    :type types: list of types</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>
<span class="sd">    :returns: The &quot;pipe_index&quot; argument and the new index. The new index is a pandas.Series where</span>
<span class="sd">        every element is a unicode object. The Series&#39; index corresponds to the quarterLength</span>
<span class="sd">        offset of the event in the input Stream.</span>
<span class="sd">    :rtype: 2-tuple of any and pandas.Series</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># NB: It&#39;s hard to tell, but this function is based on music21.stream.Stream.chordify()</span>
    <span class="c"># NB2: This must not be a single-line if/else statement, or the getter() call will fail.</span>
    <span class="k">if</span> <span class="n">types</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">getter</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">thing</span><span class="p">:</span> <span class="n">thing</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">getter</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">thing</span><span class="p">:</span> <span class="n">thing</span><span class="o">.</span><span class="n">getElementsByClass</span><span class="p">(</span><span class="n">types</span><span class="p">)</span>

    <span class="c"># Convert &quot;frozen&quot; Streams, if needed; flatten the streams and filter classes</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="n">all_parts</span> <span class="o">=</span> <span class="p">[</span><span class="n">getter</span><span class="p">(</span><span class="n">converter</span><span class="o">.</span><span class="n">thaw</span><span class="p">(</span><span class="n">each</span><span class="p">)</span><span class="o">.</span><span class="n">flat</span><span class="p">)</span> <span class="k">for</span> <span class="n">each</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">all_parts</span> <span class="o">=</span> <span class="p">[</span><span class="n">getter</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">flat</span><span class="p">)</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">]</span>

    <span class="c"># collect all unique offsets</span>
    <span class="n">unique_offsets</span> <span class="o">=</span> <span class="n">mpi_unique_offsets</span><span class="p">(</span><span class="n">all_parts</span><span class="p">)</span>

    <span class="c"># in cases where there will be more than one event at an offset, we need this</span>
    <span class="n">offsets_for_series</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c"># Convert to requested index format</span>
    <span class="n">new_series_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">off</span> <span class="ow">in</span> <span class="n">unique_offsets</span><span class="p">:</span>
        <span class="c"># inspired by vis.controllers.analyzer._event_finder() in vis9c</span>
        <span class="n">current_events</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">all_parts</span><span class="p">:</span>  <span class="c"># find the events happening at this offset in all parts</span>
            <span class="n">current_events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">getElementsByOffset</span><span class="p">(</span><span class="n">off</span><span class="p">,</span> <span class="n">mustBeginInSpan</span><span class="o">=</span><span class="bp">False</span><span class="p">)))</span>

        <span class="c"># Arrange groups of things to index</span>
        <span class="n">current_events</span> <span class="o">=</span> <span class="p">[[</span><span class="n">event</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">current_events</span><span class="p">]]</span>

        <span class="c"># Index previously-arranged groups</span>
        <span class="k">for</span> <span class="n">each_simul</span> <span class="ow">in</span> <span class="n">current_events</span><span class="p">:</span>
            <span class="n">new_series_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indexer_func</span><span class="p">(</span><span class="n">each_simul</span><span class="p">))</span>
            <span class="n">offsets_for_series</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">off</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pipe_index</span><span class="p">,</span> <span class="n">pandas</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">new_series_data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">offsets_for_series</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="series_indexer"><a class="viewcode-back" href="../../../vis.analyzers.html#vis.analyzers.indexer.series_indexer">[docs]</a><span class="k">def</span> <span class="nf">series_indexer</span><span class="p">(</span><span class="n">pipe_index</span><span class="p">,</span> <span class="n">parts</span><span class="p">,</span> <span class="n">indexer_func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform the indexation of a part or part combination. This is a module-level function designed</span>
<span class="sd">    to ease implementation of multiprocessing with the MPController module.</span>

<span class="sd">    If your Indexer has settings, use the indexer_func() to adjust for them.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>
<span class="sd">    :param pipe_index: An identifier value for use by the caller.</span>
<span class="sd">    :type pipe_index: any</span>

<span class="sd">    :param parts: A list of at least one Series object. Every new event, or change of simlutaneity,</span>
<span class="sd">        will appear in the outputted index. Therefore, the new index will contain at least as many</span>
<span class="sd">        events as the inputted Part or Series with the most events. This is not a DataFrame, since</span>
<span class="sd">        each part will likely have different offsets.</span>
<span class="sd">    :type parts: list of pandas.Series</span>

<span class="sd">    :param indexer_func: This function transforms found events into a unicode object.</span>
<span class="sd">    :type indexer_func: function</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>
<span class="sd">    :returns: The new index where each element is a unicode object and the &quot;index&quot; of the pandas</span>
<span class="sd">        object corresponds to the offset at which each event begins. Index 0 is the argument</span>
<span class="sd">        &quot;pipe_index&quot; unchanged.</span>
<span class="sd">    :rtype: 2-tuple with &quot;pipe_index&quot; and pandas.Series or pandas.DataFrame</span>

<span class="sd">    Raises</span>
<span class="sd">    ======</span>
<span class="sd">    :raises: ValueError, if there are multiple events at an offset in any of the inputted Series.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># find the offsets at which things happen</span>
    <span class="n">all_offsets</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">Index</span><span class="p">([])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)):</span>
        <span class="n">all_offsets</span> <span class="o">=</span> <span class="n">all_offsets</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

    <span class="c"># Copy each Series with index=offset values that match all_offsets, filling in non-existant</span>
    <span class="c"># offsets with the value that was at the most recent offset with a value. We put these in a</span>
    <span class="c"># dict so DataFrame.__init__() puts parts in columns.</span>
    <span class="n">in_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">part</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">all_offsets</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;ffill&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">part</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">parts</span><span class="p">)}</span>
    <span class="n">dframe</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">in_dict</span><span class="p">)</span>

    <span class="c"># do the indexing</span>
    <span class="n">new_series_data</span> <span class="o">=</span> <span class="n">dframe</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">indexer_func</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c"># make the new index</span>
    <span class="k">return</span> <span class="n">pipe_index</span><span class="p">,</span> <span class="n">new_series_data</span>

</div>
<div class="viewcode-block" id="Indexer"><a class="viewcode-back" href="../../../vis.analyzers.html#vis.analyzers.indexer.Indexer">[docs]</a><span class="k">class</span> <span class="nc">Indexer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create an index of a music21 stream.</span>

<span class="sd">    Use the &quot;requires_score&quot; attribute to know whether the __init__() method should be given a</span>
<span class="sd">    list of music21.stream.Part objects. If False, use the &quot;required_indices&quot; attribute to get a</span>
<span class="sd">    list of the names of Indexers that should be provided instead.</span>

<span class="sd">    The name of the indexer, as stored in an IndexedPiece, is the unicode-format version of the</span>
<span class="sd">    class name.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># just the standard instance variables</span>
    <span class="n">required_score_type</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">possible_settings</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">default_settings</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c"># self._score</span>
    <span class="c"># self._indexer_func</span>
    <span class="c"># self._types</span>

    <span class="c"># Ignore that we don&#39;t use the &quot;settings&quot; argument in this method. Subclasses handle it.</span>
    <span class="c"># pylint: disable=W0613</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">settings</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new Indexer.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        :param score: Depending on how this Indexer works, this is a list of either Part or Series</span>
<span class="sd">            obejcts to use in creating a new index.</span>
<span class="sd">        :type score: list of pandas.Series or of music21.stream.Part</span>

<span class="sd">        :param settings: A dict of all the settings required by this Indexer. All required</span>
<span class="sd">            settings should be listed in subclasses. Default is None.</span>
<span class="sd">        :type settings: dict or None</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        :raises: RuntimeError, if</span>
<span class="sd">            - the &quot;score&quot; argument is not a list of the right type.</span>
<span class="sd">            - required settings are not present in the &quot;settings&quot; argument.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Check the &quot;score&quot; argument is either uniformly Part or Series objects.</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">score</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">required_score_type</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s">u&#39;{} requires {} objects, not {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">,</span>
                                                               <span class="bp">self</span><span class="o">.</span><span class="n">required_score_type</span><span class="p">,</span>
                                                               <span class="nb">type</span><span class="p">(</span><span class="n">elem</span><span class="p">))</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c"># Call our superclass constructor, then set instance variables</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Indexer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_score</span> <span class="o">=</span> <span class="n">score</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indexer_func</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_types</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">u&#39;_settings&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span> <span class="o">=</span> <span class="p">{}</span>

<div class="viewcode-block" id="Indexer.run"><a class="viewcode-back" href="../../../vis.analyzers.html#vis.analyzers.indexer.Indexer.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a new index of the piece.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        :returns: A list of the new indices. The index of each Series corresponds to the index of</span>
<span class="sd">            the Part used to generate it, in the order specified to the constructor. Each element in</span>
<span class="sd">            the Series is an instance of music21.base.ElementWrapper.</span>
<span class="sd">        :rtype: list of pandas.Series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>
</div>
    <span class="k">def</span> <span class="nf">_do_multiprocessing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">combos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Index each part combination and await the jobs&#39; completion. In the future, this method</span>
<span class="sd">        may use multiprocessing.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        :param combos: A list of all voice combinations to be analyzed. For example:</span>
<span class="sd">            - [[0], [1], [2], [3]]</span>
<span class="sd">                Analyze each of four parts independently.</span>
<span class="sd">            - [[0, 1], [0, 2], [0, 3]]</span>
<span class="sd">                Analyze the highest part compared with all others.</span>
<span class="sd">            - [[0, 1, 2, 3]]</span>
<span class="sd">                Analyze all parts at once.</span>
<span class="sd">            The function stored in &quot;self._indexer_func&quot; must know how to deal with the number of</span>
<span class="sd">            simultaneous events it will receive.</span>
<span class="sd">        :type combos: list of list of integers</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        :returns: Analysis results.</span>
<span class="sd">        :rtype: list of pandas.Series</span>

<span class="sd">        Side Effects</span>
<span class="sd">        ============</span>
<span class="sd">        Blocks until all voice combinations have completed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">post</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># use serial processing</span>
        <span class="k">for</span> <span class="n">each_combo</span> <span class="ow">in</span> <span class="n">combos</span><span class="p">:</span>
            <span class="n">voices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_score</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">each_combo</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_score</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">stream</span><span class="o">.</span><span class="n">Stream</span><span class="p">):</span>
                <span class="n">post</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stream_indexer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">voices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexer_func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_types</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">post</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">series_indexer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">voices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexer_func</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">post</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">vis X documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Christopher Antila.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b2.
    </div>
  </body>
</html>